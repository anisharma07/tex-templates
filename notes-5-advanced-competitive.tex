\documentclass[10pt,a4paper]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[colorlinks=true, allcolors=black]{hyperref}

% Custom title page and TOC formatting
\makeatletter
\renewcommand\tableofcontents{%
    \begin{center}
    {\Large\bfseries\contentsname}\par
    \vspace{1em}
    \end{center}
    \@starttoc{toc}
}
\makeatother

\definecolor{codegreen}{RGB}{0,128,0}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codeblue}{RGB}{0,0,255}
\definecolor{backcolour}{RGB}{245,245,245}

\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\newtcolorbox{optimizebox}{colback=blue!5,colframe=blue!75!black,title=\textbf{âš¡ Optimization}}
\newtcolorbox{pitfallbox}{colback=red!5,colframe=red!75!black,title=\textbf{âš  Common Pitfall}}
\newtcolorbox{constraintbox}{colback=green!5,colframe=green!75!black,title=\textbf{ðŸ“Š Constraint Analysis}}
\newtcolorbox{trickbox}{colback=orange!5,colframe=orange!75!black,title=\textbf{ðŸŽ¯ Competitive Trick}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.4em}

\title{
    \vspace{2cm}
    {\Huge\bfseries Asymptotic Analysis}
    \vspace{1cm}
    
    {\Large Advanced Notes for Competitive Programming}
    \vspace{2cm}
}
\author{}
\date{\today}

\begin{document}

\begin{titlepage}
    \centering
    \vfill
    {\Huge\bfseries Asymptotic Analysis}\par
    \vspace{1.5cm}
    {\Large Advanced Notes for Competitive Programming}\par
    \vfill
    {\large \today}\par
    \vfill
\end{titlepage}
\newpage

\tableofcontents
\newpage

\section{Complexity Analysis for Competitions}

\subsection{Time Limits and Constraints}

\begin{constraintbox}
\textbf{Rule of thumb:} Modern judges execute $\sim 10^8$ to $10^9$ simple operations per second.

\textbf{Safe complexity bounds per time limit:}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Time Limit} & \textbf{Max n} & \textbf{Complexity} \\
\hline
1 sec & $10^8$ & $O(n), O(n \lg n)$ \\
1 sec & $10^7$ & $O(n \lg n)$ \\
1 sec & $10^4$ & $O(n^2)$ \\
1 sec & $500$ & $O(n^3)$ \\
1 sec & $100$ & $O(n^4)$ \\
1 sec & $25$ & $O(2^n)$ \\
1 sec & $11$ & $O(n!)$ \\
\hline
\end{tabular}
\end{center}
\end{constraintbox}

\begin{trickbox}
\textbf{Given constraint, choose algorithm:}
\begin{itemize}[nosep]
\item $n \leq 10$: $O(n!)$, $O(2^n \cdot n^2)$ acceptable
\item $n \leq 20$: $O(2^n)$, $O(n^2 \cdot 2^n)$
\item $n \leq 100$: $O(n^4)$
\item $n \leq 500$: $O(n^3)$
\item $n \leq 10^4$: $O(n^2)$
\item $n \leq 10^6$: $O(n \lg n)$
\item $n \leq 10^8$: $O(n)$, $O(\lg n)$
\end{itemize}
\end{trickbox}

\subsection{Exact Operation Counts}

Don't just know Big-O â€” know the constant!

\begin{optimizebox}
\textbf{Examples of hidden constants:}
\begin{itemize}[nosep]
\item Merge sort: $\sim 2n \lg n$ comparisons
\item Quick sort (avg): $\sim 1.39n \lg n$ comparisons
\item Heap sort: $\sim 2n \lg n$ comparisons
\item std::sort (C++): Hybrid, $\sim 1.5n \lg n$ on average
\end{itemize}

If time limit is tight, $O(n \lg n)$ algorithms can differ by 2x in practice!
\end{optimizebox}

\section{Advanced Asymptotic Relations}

\subsection{Key Inequalities for Bounding}

\textbf{For proving upper/lower bounds:}
\begin{align*}
\sum_{i=1}^n i &= \frac{n(n+1)}{2} = \Theta(n^2) \\
\sum_{i=1}^n i^2 &= \frac{n(n+1)(2n+1)}{6} = \Theta(n^3) \\
\sum_{i=1}^n i^k &= \Theta(n^{k+1}) \\
\sum_{i=0}^{\lg n} 2^i &= 2^{\lg n + 1} - 1 = 2n - 1 = \Theta(n) \\
\sum_{i=0}^n r^i &= \frac{r^{n+1}-1}{r-1} = \Theta(r^n) \quad (r > 1)
\end{align*}

\textbf{Harmonic series:}
$$H_n = \sum_{i=1}^n \frac{1}{i} = \Theta(\lg n)$$

\begin{trickbox}
\textbf{Telescoping sums:} If loop counter changes by division/multiplication:
$$\text{Iterations} = \lg(\text{range})$$

Example: for i=1 to n, i*=2 $\to$ $\Theta(\lg n)$ iterations
\end{trickbox}

\subsection{Master Theorem (Extended)}

For recurrences $T(n) = aT(n/b) + f(n)$ where $a \geq 1, b > 1$:

Let $c_{crit} = \log_b a$

\textbf{Case 1:} If $f(n) = O(n^c)$ for some $c < c_{crit}$, then
$$T(n) = \Theta(n^{c_{crit}})$$

\textbf{Case 2:} If $f(n) = \Theta(n^{c_{crit}} \log^k n)$ for some $k \geq 0$, then
$$T(n) = \Theta(n^{c_{crit}} \log^{k+1} n)$$

\textbf{Case 3:} If $f(n) = \Omega(n^c)$ for some $c > c_{crit}$, and $af(n/b) \leq \delta f(n)$ for some $\delta < 1$ and large $n$, then
$$T(n) = \Theta(f(n))$$

\begin{optimizebox}
\textbf{Common applications:}
\begin{align*}
T(n) = 2T(n/2) + O(n) &= O(n \lg n) \quad \text{(Merge sort)} \\
T(n) = 2T(n/2) + O(1) &= O(n) \quad \text{(Binary search on sorted array)} \\
T(n) = T(n/2) + O(1) &= O(\lg n) \quad \text{(Binary search)} \\
T(n) = 2T(n/2) + O(n^2) &= O(n^2) \\
T(n) = 8T(n/2) + O(n^2) &= O(n^3)
\end{align*}
\end{optimizebox}

\subsection{Amortized Analysis Techniques}

\textbf{Three methods:}

\textbf{1. Aggregate method:} Total cost / number of operations

\textbf{2. Accounting method:} Assign costs to operations, some pay for future ops

\textbf{3. Potential method:} Define potential function $\Phi$, amortized cost = actual cost + $\Delta\Phi$

\begin{trickbox}
\textbf{Classic example:} Dynamic array doubling

Each insertion: $O(1)$ amortized, despite occasional $O(n)$ resize

\textbf{Proof (aggregate):}
\begin{itemize}[nosep]
\item After $n$ insertions, total cost = $n + (1 + 2 + 4 + \cdots + 2^{\lg n})$
\item Geometric series sums to $2n - 1 = O(n)$
\item Amortized: $O(n)/n = O(1)$
\end{itemize}
\end{trickbox}

\section{Logarithm Tricks and Identities}

\subsection{Essential Identities}

\begin{align*}
\log(ab) &= \log a + \log b \\
\log(a/b) &= \log a - \log b \\
\log(a^k) &= k \log a \\
a^{\log_b c} &= c^{\log_b a} \\
\log_b a &= \frac{\log_c a}{\log_c b} = \frac{1}{\log_a b} \\
b^{\log_b a} &= a
\end{align*}

\begin{optimizebox}
\textbf{Bit manipulation shortcut:}
$$\lg n = \lfloor \log_2 n \rfloor = \text{MSB position}$$

In C++: \texttt{\_\_builtin\_clz(n)} gives leading zeros, so $\lg n \approx 31 - \texttt{\_\_builtin\_clz(n)}$
\end{optimizebox}

\subsection{Approximations}

For positive $x$:
\begin{align*}
\ln(1 + x) &\approx x - \frac{x^2}{2} \quad (|x| < 1) \\
e^x &\approx 1 + x + \frac{x^2}{2} \quad (|x| \ll 1) \\
(1 + x)^n &\approx 1 + nx \quad (|nx| \ll 1)
\end{align*}

\textbf{Stirling's approximation:}
$$\ln(n!) = n \ln n - n + O(\ln n) = \Theta(n \ln n)$$

More precisely:
$$n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n$$

\begin{trickbox}
For computing large binomial coefficients:
$$\binom{n}{k} = \frac{n!}{k!(n-k)!}$$

Use logarithms to avoid overflow:
$$\log \binom{n}{k} = \log(n!) - \log(k!) - \log((n-k)!)$$
\end{trickbox}

\section{Optimization Techniques}

\subsection{Constant Factor Optimizations}

\begin{optimizebox}
\textbf{1. Bit operations over arithmetic:}
\begin{itemize}[nosep]
\item $n * 2 \to n \ll 1$
\item $n / 2 \to n \gg 1$
\item $n \bmod 2^k \to n \& ((1 \ll k) - 1)$
\end{itemize}

\textbf{2. Minimize memory accesses:}
\begin{itemize}[nosep]
\item Cache locality matters: access arrays sequentially
\item 2D arrays: row-major order (C++) or column-major (Fortran)
\end{itemize}

\textbf{3. Avoid function calls in tight loops:}
\begin{itemize}[nosep]
\item Inline functions
\item Macro expansion (use carefully)
\end{itemize}
\end{optimizebox}

\subsection{Algorithmic Optimizations}

\begin{trickbox}
\textbf{Reduce complexity class:}

\textbf{Problem:} Find pair summing to target in array

\textbf{Naive:} $O(n^2)$ - check all pairs

\textbf{Optimized:} $O(n \lg n)$ - sort + two pointers OR $O(n)$ - hash set

\vspace{0.5em}

\textbf{Problem:} Range sum queries

\textbf{Naive:} $O(n)$ per query

\textbf{Optimized:} $O(n)$ precomputation + $O(1)$ per query (prefix sums)
\end{trickbox}

\subsection{Space-Time Tradeoffs}

\begin{optimizebox}
\textbf{Common patterns:}

\textbf{1. Memoization / DP:}
\begin{itemize}[nosep]
\item Time: $O(\text{exponential}) \to O(\text{polynomial})$
\item Space: $O(1) \to O(\text{state space})$
\end{itemize}

\textbf{2. Precomputation:}
\begin{itemize}[nosep]
\item Compute once, query many times
\item Example: Factorials mod $p$, prefix sums, LCA preprocessing
\end{itemize}

\textbf{3. Hash tables:}
\begin{itemize}[nosep]
\item Time: $O(n) \to O(1)$ lookup
\item Space: $O(1) \to O(n)$
\end{itemize}
\end{optimizebox}

\section{Analysis of Common Algorithms}

\subsection{Sorting}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Algorithm} & \textbf{Best} & \textbf{Avg} & \textbf{Worst} \\
\hline
Bubble Sort & $O(n)$ & $O(n^2)$ & $O(n^2)$ \\
Insertion Sort & $O(n)$ & $O(n^2)$ & $O(n^2)$ \\
Selection Sort & $O(n^2)$ & $O(n^2)$ & $O(n^2)$ \\
Merge Sort & $O(n \lg n)$ & $O(n \lg n)$ & $O(n \lg n)$ \\
Quick Sort & $O(n \lg n)$ & $O(n \lg n)$ & $O(n^2)$ \\
Heap Sort & $O(n \lg n)$ & $O(n \lg n)$ & $O(n \lg n)$ \\
Counting Sort & $O(n+k)$ & $O(n+k)$ & $O(n+k)$ \\
Radix Sort & $O(d(n+k))$ & $O(d(n+k))$ & $O(d(n+k))$ \\
\hline
\end{tabular}
\end{center}

\begin{pitfallbox}
\textbf{Quick sort worst case:}

Occurs on already sorted input if pivot is always first/last element.

\textbf{Fix:} Randomized pivot selection $\to$ expected $O(n \lg n)$
\end{pitfallbox}

\subsection{Graph Algorithms}

Let $V$ = vertices, $E$ = edges

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Algorithm} & \textbf{Time} & \textbf{Space} \\
\hline
BFS & $O(V + E)$ & $O(V)$ \\
DFS & $O(V + E)$ & $O(V)$ \\
Dijkstra (binary heap) & $O((V+E) \lg V)$ & $O(V)$ \\
Dijkstra (Fib heap) & $O(E + V \lg V)$ & $O(V)$ \\
Bellman-Ford & $O(VE)$ & $O(V)$ \\
Floyd-Warshall & $O(V^3)$ & $O(V^2)$ \\
Kruskal & $O(E \lg E)$ & $O(V)$ \\
Prim (binary heap) & $O((V+E) \lg V)$ & $O(V)$ \\
Topological Sort & $O(V + E)$ & $O(V)$ \\
\hline
\end{tabular}
\end{center}

\begin{trickbox}
\textbf{When to use which shortest path:}
\begin{itemize}[nosep]
\item Single source, non-negative: Dijkstra
\item Single source, negative edges: Bellman-Ford
\item All pairs, dense graph: Floyd-Warshall
\item All pairs, sparse graph: Dijkstra from each vertex
\end{itemize}
\end{trickbox}

\subsection{Data Structures}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Structure} & \textbf{Access} & \textbf{Search} & \textbf{Insert/Delete} \\
\hline
Array & $O(1)$ & $O(n)$ & $O(n)$ \\
Sorted Array & $O(1)$ & $O(\lg n)$ & $O(n)$ \\
Linked List & $O(n)$ & $O(n)$ & $O(1)^*$ \\
Stack/Queue & - & - & $O(1)$ \\
Hash Table & - & $O(1)$ avg & $O(1)$ avg \\
BST (balanced) & $O(\lg n)$ & $O(\lg n)$ & $O(\lg n)$ \\
Heap & $O(1)$ min & - & $O(\lg n)$ \\
Segment Tree & $O(\lg n)$ & $O(\lg n)$ & $O(\lg n)$ \\
Fenwick Tree & - & $O(\lg n)$ & $O(\lg n)$ \\
\hline
\multicolumn{4}{l}{$^*$ Given pointer to position}
\end{tabular}
\end{center}

\section{Common Pitfalls and Edge Cases}

\begin{pitfallbox}
\textbf{1. Integer overflow:}

When $n \approx 10^9$, $n^2$ overflows 32-bit int!

\textbf{Solutions:}
\begin{itemize}[nosep]
\item Use 64-bit: \texttt{long long} in C++
\item Modular arithmetic when appropriate
\end{itemize}
\end{pitfallbox}

\begin{pitfallbox}
\textbf{2. Off-by-one errors in complexity:}

$\sum_{i=0}^{n-1}$ vs $\sum_{i=1}^{n}$ - both are $O(n)$, but exact count differs by 1

Critical when time limit is tight!
\end{pitfallbox}

\begin{pitfallbox}
\textbf{3. Hidden logarithmic factors:}

\texttt{std::set::find()}, \texttt{std::map::operator[]} are $O(\lg n)$, not $O(1)$!

Loop with set operations: actually $O(n \lg n)$, not $O(n)$
\end{pitfallbox}

\begin{pitfallbox}
\textbf{4. Amortized vs worst-case:}

\texttt{std::vector::push\_back()} is $O(1)$ amortized, but $O(n)$ worst-case

If real-time guarantees needed, consider \texttt{std::deque} or pre-reserve
\end{pitfallbox}

\section{Advanced Bounds}

\subsection{Comparison-Based Sorting Lower Bound}

\begin{constraintbox}
\textbf{Theorem:} Any comparison-based sorting algorithm requires $\Omega(n \lg n)$ comparisons in the worst case.

\textbf{Proof idea:} Decision tree has $n!$ leaves, height $\geq \lg(n!) = \Theta(n \lg n)$
\end{constraintbox}

\textbf{Implication:} To beat $O(n \lg n)$, must use non-comparison-based algorithm (counting sort, radix sort) with assumptions about input.

\subsection{3SUM Lower Bound Conjecture}

\begin{constraintbox}
\textbf{3SUM Problem:} Given array, find three elements summing to 0.

\textbf{Best known:} $O(n^2)$

\textbf{Conjecture:} No $O(n^{2-\epsilon})$ algorithm exists (for any $\epsilon > 0$)

Many problems are 3SUM-hard, meaning they're at least as hard as 3SUM.
\end{constraintbox}

\section{Final Competitive Tips}

\begin{trickbox}
\textbf{1. Quick estimation:}

Input size $\to$ complexity $\to$ algorithm choice

This should take < 10 seconds in your head!

\textbf{2. Worst-case analysis:}

Always analyze worst case unless problem explicitly asks for average

\textbf{3. Constant factors:}

If $O(n \lg n)$ TLEs, try optimizing constant (e.g., iterative vs recursive)

\textbf{4. Space limits:}

$10^6$ ints $\approx 4$ MB, $10^6$ longs $\approx 8$ MB

\textbf{5. Pre-written templates:}

Have complexity analysis of your library code memorized

\textbf{6. Profile, don't guess:}

If optimization needed, profile to find bottleneck
\end{trickbox}

\end{document}
